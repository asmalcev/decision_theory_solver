/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/fraction.js/fraction.js":
/*!**********************************************!*\
  !*** ./node_modules/fraction.js/fraction.js ***!
  \**********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license Fraction.js v4.1.2 23/05/2021\n * https://www.xarg.org/2014/03/rational-numbers-in-javascript/\n *\n * Copyright (c) 2021, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <nominator>, 1 => <denominator> ]\n * [ n => <nominator>, d => <denominator> ]\n *\n * Integer form\n * - Single integer value\n *\n * Double form\n * - Single double value\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n *\n * var f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n(function(root) {\n\n  \"use strict\";\n\n  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\n  var MAX_CYCLE_LEN = 2000;\n\n  // Parsed data to avoid calling \"new\" all the time\n  var P = {\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1\n  };\n\n  function createError(name) {\n\n    function errorConstructor() {\n      var temp = Error.apply(this, arguments);\n      temp['name'] = this['name'] = name;\n      this['stack'] = temp['stack'];\n      this['message'] = temp['message'];\n    }\n\n    /**\n     * Error constructor\n     *\n     * @constructor\n     */\n    function IntermediateInheritor() { }\n    IntermediateInheritor.prototype = Error.prototype;\n    errorConstructor.prototype = new IntermediateInheritor();\n\n    return errorConstructor;\n  }\n\n  var DivisionByZero = Fraction['DivisionByZero'] = createError('DivisionByZero');\n  var InvalidParameter = Fraction['InvalidParameter'] = createError('InvalidParameter');\n\n  function assign(n, s) {\n\n    if (isNaN(n = parseInt(n, 10))) {\n      throwInvalidParam();\n    }\n    return n * s;\n  }\n\n  function throwInvalidParam() {\n    throw new InvalidParameter();\n  }\n\n  function factorize(num) {\n\n    var factors = {};\n\n    var n = num;\n    var i = 2;\n    var s = 4;\n\n    while (s <= n) {\n\n      while (n % i === 0) {\n        n /= i;\n        factors[i] = (factors[i] || 0) + 1;\n      }\n      s += 1 + 2 * i++;\n    }\n\n    if (n !== num) {\n      if (n > 1)\n      factors[n] = (factors[n] || 0) + 1;\n    } else {\n      factors[num] = (factors[num] || 0) + 1;\n    }\n    return factors;\n  }\n\n  var parse = function(p1, p2) {\n\n    var n = 0, d = 1, s = 1;\n    var v = 0, w = 0, x = 0, y = 1, z = 1;\n\n    var A = 0, B = 1;\n    var C = 1, D = 1;\n\n    var N = 10000000;\n    var M;\n\n    if (p1 === undefined || p1 === null) {\n      /* void */\n    } else if (p2 !== undefined) {\n      n = p1;\n      d = p2;\n      s = n * d;\n    } else\n      switch (typeof p1) {\n\n        case \"object\":\n          {\n            if (\"d\" in p1 && \"n\" in p1) {\n              n = p1[\"n\"];\n              d = p1[\"d\"];\n              if (\"s\" in p1)\n                n *= p1[\"s\"];\n            } else if (0 in p1) {\n              n = p1[0];\n              if (1 in p1)\n                d = p1[1];\n            } else {\n              throwInvalidParam();\n            }\n            s = n * d;\n            break;\n          }\n        case \"number\":\n          {\n            if (p1 < 0) {\n              s = p1;\n              p1 = -p1;\n            }\n\n            if (p1 % 1 === 0) {\n              n = p1;\n            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow\n\n              if (p1 >= 1) {\n                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));\n                p1 /= z;\n              }\n\n              // Using Farey Sequences\n              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/\n\n              while (B <= N && D <= N) {\n                M = (A + C) / (B + D);\n\n                if (p1 === M) {\n                  if (B + D <= N) {\n                    n = A + C;\n                    d = B + D;\n                  } else if (D > B) {\n                    n = C;\n                    d = D;\n                  } else {\n                    n = A;\n                    d = B;\n                  }\n                  break;\n\n                } else {\n\n                  if (p1 > M) {\n                    A += C;\n                    B += D;\n                  } else {\n                    C += A;\n                    D += B;\n                  }\n\n                  if (B > N) {\n                    n = C;\n                    d = D;\n                  } else {\n                    n = A;\n                    d = B;\n                  }\n                }\n              }\n              n *= z;\n            } else if (isNaN(p1) || isNaN(p2)) {\n              d = n = NaN;\n            }\n            break;\n          }\n        case \"string\":\n          {\n            B = p1.match(/\\d+|./g);\n\n            if (B === null)\n              throwInvalidParam();\n\n            if (B[A] === '-') {// Check for minus sign at the beginning\n              s = -1;\n              A++;\n            } else if (B[A] === '+') {// Check for plus sign at the beginning\n              A++;\n            }\n\n            if (B.length === A + 1) { // Check if it's just a simple number \"1234\"\n              w = assign(B[A++], s);\n            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number\n\n              if (B[A] !== '.') { // Handle 0.5 and .5\n                v = assign(B[A++], s);\n              }\n              A++;\n\n              // Check for decimal places\n              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === \"'\" && B[A + 3] === \"'\") {\n                w = assign(B[A], s);\n                y = Math.pow(10, B[A].length);\n                A++;\n              }\n\n              // Check for repeating places\n              if (B[A] === '(' && B[A + 2] === ')' || B[A] === \"'\" && B[A + 2] === \"'\") {\n                x = assign(B[A + 1], s);\n                z = Math.pow(10, B[A + 1].length) - 1;\n                A += 3;\n              }\n\n            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n              w = assign(B[A], s);\n              y = assign(B[A + 2], 1);\n              A += 3;\n            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n              v = assign(B[A], s);\n              w = assign(B[A + 2], s);\n              y = assign(B[A + 4], 1);\n              A += 5;\n            }\n\n            if (B.length <= A) { // Check for more tokens on the stack\n              d = y * z;\n              s = /* void */\n              n = x + d * v + z * w;\n              break;\n            }\n\n            /* Fall through on error */\n          }\n        default:\n          throwInvalidParam();\n      }\n\n    if (d === 0) {\n      throw new DivisionByZero();\n    }\n\n    P[\"s\"] = s < 0 ? -1 : 1;\n    P[\"n\"] = Math.abs(n);\n    P[\"d\"] = Math.abs(d);\n  };\n\n  function modpow(b, e, m) {\n\n    var r = 1;\n    for (; e > 0; b = (b * b) % m, e >>= 1) {\n\n      if (e & 1) {\n        r = (r * b) % m;\n      }\n    }\n    return r;\n  }\n\n\n  function cycleLen(n, d) {\n\n    for (; d % 2 === 0;\n      d /= 2) {\n    }\n\n    for (; d % 5 === 0;\n      d /= 5) {\n    }\n\n    if (d === 1) // Catch non-cyclic numbers\n      return 0;\n\n    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n    // 10^(d-1) % d == 1\n    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n    // as we want to translate the numbers to strings.\n\n    var rem = 10 % d;\n    var t = 1;\n\n    for (; rem !== 1; t++) {\n      rem = rem * 10 % d;\n\n      if (t > MAX_CYCLE_LEN)\n        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n    }\n    return t;\n  }\n\n\n  function cycleStart(n, d, len) {\n\n    var rem1 = 1;\n    var rem2 = modpow(10, len, d);\n\n    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n      // Solve 10^s == 10^(s+t) (mod d)\n\n      if (rem1 === rem2)\n        return t;\n\n      rem1 = rem1 * 10 % d;\n      rem2 = rem2 * 10 % d;\n    }\n    return 0;\n  }\n\n  function gcd(a, b) {\n\n    if (!a)\n      return b;\n    if (!b)\n      return a;\n\n    while (1) {\n      a %= b;\n      if (!a)\n        return b;\n      b %= a;\n      if (!b)\n        return a;\n    }\n  };\n\n  /**\n   * Module constructor\n   *\n   * @constructor\n   * @param {number|Fraction=} a\n   * @param {number=} b\n   */\n  function Fraction(a, b) {\n\n    if (!(this instanceof Fraction)) {\n      return new Fraction(a, b);\n    }\n\n    parse(a, b);\n\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse variable a\n\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  }\n\n  Fraction.prototype = {\n\n    \"s\": 1,\n    \"n\": 0,\n    \"d\": 1,\n\n    /**\n     * Calculates the absolute value\n     *\n     * Ex: new Fraction(-4).abs() => 4\n     **/\n    \"abs\": function() {\n\n      return new Fraction(this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Inverts the sign of the current fraction\n     *\n     * Ex: new Fraction(-4).neg() => 4\n     **/\n    \"neg\": function() {\n\n      return new Fraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n    },\n\n    /**\n     * Adds two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n     **/\n    \"add\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Subtracts two rational numbers\n     *\n     * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n     **/\n    \"sub\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Multiplies two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n     **/\n    \"mul\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n        this[\"d\"] * P[\"d\"]\n      );\n    },\n\n    /**\n     * Divides two rational numbers\n     *\n     * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n     **/\n    \"div\": function(a, b) {\n\n      parse(a, b);\n      return new Fraction(\n        this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n        this[\"d\"] * P[\"n\"]\n      );\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * Ex: new Fraction(\"-17.(345)\").clone()\n     **/\n    \"clone\": function() {\n      return new Fraction(this);\n    },\n\n    /**\n     * Calculates the modulo of two rational numbers - a more precise fmod\n     *\n     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n     **/\n    \"mod\": function(a, b) {\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return new Fraction(NaN);\n      }\n\n      if (a === undefined) {\n        return new Fraction(this[\"s\"] * this[\"n\"] % this[\"d\"], 1);\n      }\n\n      parse(a, b);\n      if (0 === P[\"n\"] && 0 === this[\"d\"]) {\n        Fraction(0, 0); // Throw DivisionByZero\n      }\n\n      /*\n       * First silly attempt, kinda slow\n       *\n       return that[\"sub\"]({\n       \"n\": num[\"n\"] * Math.floor((this.n / this.d) / (num.n / num.d)),\n       \"d\": num[\"d\"],\n       \"s\": this[\"s\"]\n       });*/\n\n      /*\n       * New attempt: a1 / b1 = a2 / b2 * q + r\n       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r\n       * => (b2 * a1 % a2 * b1) / (b1 * b2)\n       */\n      return new Fraction(\n        this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n        P[\"d\"] * this[\"d\"]\n      );\n    },\n\n    /**\n     * Calculates the fractional gcd of two rational numbers\n     *\n     * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n     */\n    \"gcd\": function(a, b) {\n\n      parse(a, b);\n\n      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n      return new Fraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n    },\n\n    /**\n     * Calculates the fractional lcm of two rational numbers\n     *\n     * Ex: new Fraction(5,8).lcm(3,7) => 15\n     */\n    \"lcm\": function(a, b) {\n\n      parse(a, b);\n\n      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n      if (P[\"n\"] === 0 && this[\"n\"] === 0) {\n        return new Fraction;\n      }\n      return new Fraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n    },\n\n    /**\n     * Calculates the ceil of a rational number\n     *\n     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n     **/\n    \"ceil\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.ceil(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Calculates the floor of a rational number\n     *\n     * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n     **/\n    \"floor\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.floor(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Rounds a rational numbers\n     *\n     * Ex: new Fraction('4.(3)').round() => (4 / 1)\n     **/\n    \"round\": function(places) {\n\n      places = Math.pow(10, places || 0);\n\n      if (isNaN(this[\"n\"]) || isNaN(this[\"d\"])) {\n        return new Fraction(NaN);\n      }\n      return new Fraction(Math.round(places * this[\"s\"] * this[\"n\"] / this[\"d\"]), places);\n    },\n\n    /**\n     * Gets the inverse of the fraction, means numerator and denominator are exchanged\n     *\n     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n     **/\n    \"inverse\": function() {\n\n      return new Fraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n    },\n\n    /**\n     * Calculates the fraction to some rational exponent, if possible\n     *\n     * Ex: new Fraction(-1,2).pow(-3) => -8\n     */\n    \"pow\": function(a, b) {\n\n      parse(a, b);\n\n      // Trivial case when exp is an integer\n\n      if (P['d'] === 1) {\n\n        if (P['s'] < 0) {\n          return new Fraction(Math.pow(this['s'] * this[\"d\"], P['n']), Math.pow(this[\"n\"], P['n']));\n        } else {\n          return new Fraction(Math.pow(this['s'] * this[\"n\"], P['n']), Math.pow(this[\"d\"], P['n']));\n        }\n      }\n\n      // Negative roots become complex\n      //     (-a/b)^(c/d) = x\n      // <=> (-1)^(c/d) * (a/b)^(c/d) = x\n      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180Â°\n      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )\n      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.\n      if (this['s'] < 0) return null;\n\n      // Now prime factor n and d\n      var N = factorize(this['n']);\n      var D = factorize(this['d']);\n\n      // Exponentiate and take root for n and d individually\n      var n = 1;\n      var d = 1;\n      for (var k in N) {\n        if (k === '1') continue;\n        if (k === '0') {\n          n = 0;\n          break;\n        }\n        N[k]*= P['n'];\n\n        if (N[k] % P['d'] === 0) {\n          N[k]/= P['d'];\n        } else return null;\n        n*= Math.pow(k, N[k]);\n      }\n\n      for (var k in D) {\n        if (k === '1') continue;\n        D[k]*= P['n'];\n\n        if (D[k] % P['d'] === 0) {\n          D[k]/= P['d'];\n        } else return null;\n        d*= Math.pow(k, D[k]);\n      }\n\n      if (P['s'] < 0) {\n        return new Fraction(d, n);\n      }\n      return new Fraction(n, d);\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"equals\": function(a, b) {\n\n      parse(a, b);\n      return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"]; // Same as compare() === 0\n    },\n\n    /**\n     * Check if two rational numbers are the same\n     *\n     * Ex: new Fraction(19.6).equals([98, 5]);\n     **/\n    \"compare\": function(a, b) {\n\n      parse(a, b);\n      var t = (this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"]);\n      return (0 < t) - (t < 0);\n    },\n\n    \"simplify\": function(eps) {\n\n      // First naive implementation, needs improvement\n\n      if (isNaN(this['n']) || isNaN(this['d'])) {\n        return this;\n      }\n\n      var cont = this['abs']()['toContinued']();\n\n      eps = eps || 0.001;\n\n      function rec(a) {\n        if (a.length === 1)\n          return new Fraction(a[0]);\n        return rec(a.slice(1))['inverse']()['add'](a[0]);\n      }\n\n      for (var i = 0; i < cont.length; i++) {\n        var tmp = rec(cont.slice(0, i + 1));\n        if (tmp['sub'](this['abs']())['abs']().valueOf() < eps) {\n          return tmp['mul'](this['s']);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Check if two rational numbers are divisible\n     *\n     * Ex: new Fraction(19.6).divisible(1.5);\n     */\n    \"divisible\": function(a, b) {\n\n      parse(a, b);\n      return !(!(P[\"n\"] * this[\"d\"]) || ((this[\"n\"] * P[\"d\"]) % (P[\"n\"] * this[\"d\"])));\n    },\n\n    /**\n     * Returns a decimal representation of the fraction\n     *\n     * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n     **/\n    'valueOf': function() {\n\n      return this[\"s\"] * this[\"n\"] / this[\"d\"];\n    },\n\n    /**\n     * Returns a string-fraction representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n     **/\n    'toFraction': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          str += \" \";\n          n %= d;\n        }\n\n        str += n;\n        str += '/';\n        str += d;\n      }\n      return str;\n    },\n\n    /**\n     * Returns a latex representation of a Fraction object\n     *\n     * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n     **/\n    'toLatex': function(excludeWhole) {\n\n      var whole, str = \"\";\n      var n = this[\"n\"];\n      var d = this[\"d\"];\n      if (this[\"s\"] < 0) {\n        str += '-';\n      }\n\n      if (d === 1) {\n        str += n;\n      } else {\n\n        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {\n          str += whole;\n          n %= d;\n        }\n\n        str += \"\\\\frac{\";\n        str += n;\n        str += '}{';\n        str += d;\n        str += '}';\n      }\n      return str;\n    },\n\n    /**\n     * Returns an array of continued fraction elements\n     *\n     * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n     */\n    'toContinued': function() {\n\n      var t;\n      var a = this['n'];\n      var b = this['d'];\n      var res = [];\n\n      if (isNaN(a) || isNaN(b)) {\n        return res;\n      }\n\n      do {\n        res.push(Math.floor(a / b));\n        t = a % b;\n        a = b;\n        b = t;\n      } while (a !== 1);\n\n      return res;\n    },\n\n    /**\n     * Creates a string representation of a fraction with all digits\n     *\n     * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n     **/\n    'toString': function(dec) {\n\n      var g;\n      var N = this[\"n\"];\n      var D = this[\"d\"];\n\n      if (isNaN(N) || isNaN(D)) {\n        return \"NaN\";\n      }\n\n      dec = dec || 15; // 15 = decimal places when no repetation\n\n      var cycLen = cycleLen(N, D); // Cycle length\n      var cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n      var str = this['s'] === -1 ? \"-\" : \"\";\n\n      str += N / D | 0;\n\n      N %= D;\n      N *= 10;\n\n      if (N)\n        str += \".\";\n\n      if (cycLen) {\n\n        for (var i = cycOff; i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \"(\";\n        for (var i = cycLen; i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n        str += \")\";\n      } else {\n        for (var i = dec; N && i--;) {\n          str += N / D | 0;\n          N %= D;\n          N *= 10;\n        }\n      }\n      return str;\n    }\n  };\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Fraction;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this);\n\n\n//# sourceURL=webpack://decision_theory_equation_solver/./node_modules/fraction.js/fraction.js?");

/***/ }),

/***/ "./src/js/_fraction.js":
/*!*****************************!*\
  !*** ./src/js/_fraction.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fraction\": () => (/* binding */ Fraction),\n/* harmony export */   \"tableToFraction\": () => (/* binding */ tableToFraction),\n/* harmony export */   \"fractionTableToStrings\": () => (/* binding */ fractionTableToStrings)\n/* harmony export */ });\nconst Fraction = __webpack_require__(/*! fraction.js */ \"./node_modules/fraction.js/fraction.js\");\n\nconst tableToFraction = table => {\n\tfor (let i = 1; i < table.length; i++) {\n\t\tfor (let j = 1; j < table[0].length; j++) {\n\t\t\ttable[i][j] = new Fraction( table[i][j] );\n\t\t}\n\t}\n}\n\nconst fractionTableToStrings = table =>\n\ttable.map( row => row.map(element => typeof element === 'string' ? element : element.toString()) );\n\n\n\n//# sourceURL=webpack://decision_theory_equation_solver/./src/js/_fraction.js?");

/***/ }),

/***/ "./src/js/equations.js":
/*!*****************************!*\
  !*** ./src/js/equations.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fraction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_fraction */ \"./src/js/_fraction.js\");\n/* harmony import */ var _table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table */ \"./src/js/table.js\");\n\n\n\n// const initTableContent = [\n// \t['', '1', 'x1', 'x2'],\n// \t['q', '', '', ''],\n// ];\n\nconst initTableContent = [\n\t['',   '1',  'x1', 'x2'],\n\t['q',  '0',  '-1',  '-3'],\n\t['x3', '1',  '-1',  '1'],\n\t['x4', '-6', '2',   '-4'],\n\t['x5', '16', '1',   '2'],\n];\n\n// const initTableContent = [\n// \t['',   '1',  'x1', 'x2'],\n// \t['q',  '0',  '-3',  '-1'],\n// \t['x3', '2',  '-1',  '2'],\n// \t['x4', '4',  '1',  '-1'],\n// ];\n\nconst deleteRow = index => {\n\tdelete initTableContent[index];\n\tloadInitTable();\n}\n\nconst addRow = () => {\n\tinitTableContent.push(['', '', '', '']);\n\tloadInitTable();\n}\n\nconst updateCell = e => {\n\tinitTableContent[e.target.dataset.row][e.target.dataset.column] = e.target.value;\n}\n\nconst tableContainer  = document.querySelector('#init-table-container');\nconst outputContainer = document.querySelector('#output-container');\nconst stepButton      = document.createElement('button');\nstepButton.id = 'next-step-button';\nstepButton.innerHTML = 'Next step';\n\nconst ELEMS_IN_ROW = 4;\n\nconst solveSteps = [];\n\ntableContainer.addEventListener('submit', e => {\n\te.preventDefault();\n\n\ttableContainer.innerHTML = '';\n\toutputContainer.appendChild( stepButton );\n\n\t(0,_fraction__WEBPACK_IMPORTED_MODULE_0__.tableToFraction)(initTableContent);\n\n\tconst stepTable = (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\ttableContent: (0,_fraction__WEBPACK_IMPORTED_MODULE_0__.fractionTableToStrings)(initTableContent)\n\t});\n\tstepTable.classList.add('step0');\n\tstepTable.classList.add('main');\n\toutputContainer.insertBefore( stepTable, stepButton );\n\n\tsolveSteps.push({\n\t\tstep: 0,\n\t\ttable: initTableContent,\n\t\tbasis: {\n\t\t\trow: null,\n\t\t\tcolumn: null\n\t\t},\n\t\tsecondary: false\n\t});\n});\n\nconst loadInitTable = () => {\n\ttableContainer.innerHTML = '';\n\ttableContainer.appendChild( (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\ttableContent: initTableContent,\n\t\tinitial: true,\n\t\taddRow: addRow,\n\t\tdeleteRow: deleteRow,\n\t\tupdateCell: updateCell\n\t}) );\n\n\tconst submitButton = document.createElement('button');\n\tsubmitButton.setAttribute('type', 'submit');\n\tsubmitButton.innerHTML = 'Submit';\n\n\ttableContainer.appendChild(submitButton);\n}\n\nloadInitTable();\n\nconst parseIntFromTH = thString => Number.parseInt(thString.match(/\\d+/)[0]);\n\nconst highlightRowBasis = (htmlTable, basisIndex) => {\n\thtmlTable.children[basisIndex * ELEMS_IN_ROW].classList.add('basis');\n\n\tconst rowsInTable = Math.round(htmlTable.children.length / ELEMS_IN_ROW);\n\tconst isLastRow = rowsInTable - 1 === basisIndex;\n\n\tconst rowTopIndex = basisIndex;\n\tconst rowBottomIndex = (\n\t\tisLastRow ?\n\t\t\tbasisIndex :\n\t\t\tbasisIndex + 1\n\t);\n\n\tconst rowBottomCSSClass = isLastRow ? 'row-basis-bottom' : 'row-basis-top';\n\n\tfor (let index = 0; index < ELEMS_IN_ROW; index++) {\n\t\thtmlTable.children[index + rowTopIndex * ELEMS_IN_ROW].classList.add('row-basis-top', 'basis');\n\t\thtmlTable.children[index + rowBottomIndex * ELEMS_IN_ROW].classList.add(rowBottomCSSClass);\n\t}\n}\n\nconst highlightColumnBasis = (htmlTable, basisIndex) => {\n\thtmlTable.children[basisIndex].classList.add('basis');\n\n\tconst rowsInTable = Math.round(htmlTable.children.length / ELEMS_IN_ROW);\n\n\tconst isLastColumn = ELEMS_IN_ROW - 1 === basisIndex;\n\n\tconst columnRightIndex = (\n\t\tisLastColumn ?\n\t\t\tbasisIndex :\n\t\t\tbasisIndex + 1\n\t);\n\n\tconst columnRightCSSClass = isLastColumn ? 'column-basis-right' : 'column-basis-left';\n\n\tfor (let index = 0; index < rowsInTable; index++) {\n\t\thtmlTable.children[index * ELEMS_IN_ROW + basisIndex].classList.add('column-basis-left', 'basis');\n\t\thtmlTable.children[index * ELEMS_IN_ROW + columnRightIndex].classList.add(columnRightCSSClass);\n\t}\n}\n\nconst countNextStep = () => {\n\tconst htmlTables = document.querySelectorAll('.grid-table');\n\tconst lastHtmlTable = htmlTables[htmlTables.length - 1];\n\n\tconst lastStep = solveSteps[solveSteps.length - 1];\n\n\tif (!lastStep.secondary) {\n\n\t\t//\n\t\t// Find column basis\n\t\t//\n\t\tconst row = lastStep.table[1];\n\t\tconst rowElements = row.map(\n\t\t\t(value, index) => {\n\t\t\t\treturn { value: value, index: index };\n\t\t\t}\n\t\t).slice(2);\n\t\tconst negativeElementsRow = rowElements.filter( obj => obj.value.compare(0) < 0 );\n\n\t\tlet columnBasis = null;\n\t\tif (negativeElementsRow.length === 1) {\n\n\t\t\tcolumnBasis = negativeElementsRow[0].index;\n\n\t\t} else {\n\n\t\t\t(negativeElementsRow.length === 0 ? rowElements : negativeElementsRow)\n\t\t\t\t.forEach(data => {\n\t\t\t\t\tconst thValue = parseIntFromTH(lastStep.table[0][data.index]);\n\n\t\t\t\t\tif (columnBasis === null) {\n\t\t\t\t\t\tcolumnBasis = {\n\t\t\t\t\t\t\tthValue: thValue,\n\t\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (columnBasis.thValue > thValue) {\n\t\t\t\t\t\tcolumnBasis = {\n\t\t\t\t\t\t\tthValue: thValue,\n\t\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tcolumnBasis = columnBasis.index;\n\t\t}\n\n\t\thighlightColumnBasis(lastHtmlTable, columnBasis);\n\n\t\t//\n\t\t// Find row basis\n\t\t//\n\t\tconst columnElements = lastStep.table.map(\n\t\t\t(row, index) => {\n\t\t\t\treturn { value: row[1], index: index };\n\t\t\t}\n\t\t).slice(2);\n\t\tconst negativeElementsColumn = columnElements.filter( obj => obj.value.compare(0) < 0 );\n\n\t\tlet rowBasis = null;\n\t\tif (negativeElementsColumn.length === 1) {\n\n\t\t\trowBasis = negativeElementsColumn[0].index;\n\n\t\t} else if (negativeElementsColumn.length > 1) {\n\n\t\t\tnegativeElementsColumn.forEach(data => {\n\t\t\t\tconst thValue = parseIntFromTH(lastStep.table[data.index][0]);\n\n\t\t\t\tif (rowBasis === null) {\n\t\t\t\t\trowBasis = {\n\t\t\t\t\t\tthValue: thValue,\n\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t}\n\t\t\t\t} else if (rowBasis.thValue > thValue) {\n\t\t\t\t\trowBasis = {\n\t\t\t\t\t\tthValue: thValue,\n\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trowBasis = rowBasis.index;\n\t\t} else {\n\n\t\t\tcolumnElements.forEach(data => {\n\t\t\t\tconst attitude = lastStep.table[data.index][columnBasis] / lastStep.table[data.index][1];\n\n\t\t\t\tif (rowBasis === null) {\n\t\t\t\t\trowBasis = {\n\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t\tattitude: attitude\n\t\t\t\t\t};\n\t\t\t\t} else if (rowBasis.attitude < attitude) {\n\t\t\t\t\trowBasis = {\n\t\t\t\t\t\tindex: data.index,\n\t\t\t\t\t\tattitude: attitude\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trowBasis = rowBasis.index;\n\t\t}\n\n\t\thighlightRowBasis(lastHtmlTable, rowBasis);\n\n\t\tlastStep.basis = {\n\t\t\trow: rowBasis,\n\t\t\tcolumn: columnBasis\n\t\t}\n\n\t\tconst nextStep = {\n\t\t\tsecondary: true,\n\t\t\tstep: lastStep.step,\n\t\t\tbasis: lastStep.basis,\n\n\t\t\ttable: [],\n\t\t}\n\n\t\tconst lambda = lastStep.table[rowBasis][columnBasis];\n\n\t\tconst tmpTable = lastStep.table.map( arr => arr.slice() );\n\n\t\ttmpTable[rowBasis][columnBasis] = lambda.inverse();\n\n\t\ttmpTable[rowBasis] = tmpTable[rowBasis].map( (value, index) => {\n\t\t\tif (index === columnBasis || index === 0) {\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn value.div( lambda );\n\t\t\t}\n\t\t});\n\n\t\tfor (let index = 1; index < tmpTable.length; index++) {\n\t\t\tif (index !== rowBasis) {\n\t\t\t\ttmpTable[index][columnBasis] = tmpTable[index][columnBasis].div( lambda.neg() );\n\t\t\t}\n\t\t}\n\n\t\tfor (let index = 1; index < tmpTable.length; index++) {\n\t\t\tif (index === rowBasis) continue;\n\t\t\tfor (let jndex = 1; jndex < tmpTable[index].length; jndex++) {\n\t\t\t\tif (jndex === columnBasis) continue;\n\n\t\t\t\ttmpTable[index][jndex] = lastStep.table[rowBasis][jndex].mul( tmpTable[index][columnBasis] );\n\t\t\t}\n\t\t}\n\n\t\tnextStep.table = tmpTable;\n\t\tconst stepTable = (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\t\ttableContent: (0,_fraction__WEBPACK_IMPORTED_MODULE_0__.fractionTableToStrings)(tmpTable)\n\t\t});\n\t\tstepTable.classList.add(`step${nextStep.step}`);\n\t\tstepTable.classList.add('secondary');\n\t\toutputContainer.insertBefore( stepTable, stepButton );\n\t\t\n\t\tsolveSteps.push( nextStep );\n\n\t} else {\n\n\t\tconst penultimateStep = solveSteps[solveSteps.length - 2];\n\n\t\tconst nextStep = {\n\t\t\tsecondary: false,\n\t\t\tstep: lastStep.step + 1,\n\t\t\tbasis: {\n\t\t\t\trow: null,\n\t\t\t\tcolumn: null\n\t\t\t},\n\n\t\t\ttable: [],\n\t\t}\n\n\t\tconst tmpTable = lastStep.table.map( arr => arr.slice() );\n\t\tfor (let index = 1; index < tmpTable.length; index++) {\n\t\t\tif (index === lastStep.basis.row) continue;\n\t\t\tfor (let jndex = 1; jndex < tmpTable[index].length; jndex++) {\n\t\t\t\tif (jndex === lastStep.basis.column) continue;\n\n\t\t\t\ttmpTable[index][jndex] = lastStep.table[index][jndex].add( penultimateStep.table[index][jndex] );\n\t\t\t}\n\t\t}\n\n\t\tconst tmp = tmpTable[lastStep.basis.row][0];\n\t\ttmpTable[lastStep.basis.row][0] = tmpTable[0][lastStep.basis.column];\n\t\ttmpTable[0][lastStep.basis.column] = tmp;\n\n\t\tnextStep.table = tmpTable;\n\t\tconst stepTable = (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\t\ttableContent: (0,_fraction__WEBPACK_IMPORTED_MODULE_0__.fractionTableToStrings)(tmpTable)\n\t\t});\n\t\tstepTable.classList.add(`step${nextStep.step}`);\n\t\tstepTable.classList.add('main');\n\t\toutputContainer.insertBefore( stepTable, stepButton );\n\t\t\n\t\tsolveSteps.push( nextStep );\n\n\t\tcheckTable();\n\t}\n\n\twindow.scrollTo(0, document.body.scrollHeight);\n}\n\nconst checkTable = () => {\n\tconst lastStep = solveSteps[solveSteps.length - 1];\n\n\tlet notNegative = true;\n\tlet areInt = true;\n\n\tfor (let index = 1; index < ELEMS_IN_ROW; index++) {\n\t\tconst element = lastStep.table[1][index];\n\t\tif (element.compare(0) < 0) {\n\t\t\tnotNegative = false;\n\t\t}\n\t\tif (element.d !== 1) {\n\t\t\tareInt = false;\n\t\t}\n\t}\n\n\tfor (let index = 2; index < lastStep.table.length; index++) {\n\t\tconst element = lastStep.table[index][1];\n\t\tif (element.compare(0) < 0) {\n\t\t\tnotNegative = false;\n\t\t}\n\t\tif (element.d !== 1) {\n\t\t\tareInt = false;\n\t\t}\n\t}\n\n\tif (notNegative) {\n\t\tif (areInt) {\n\t\t\tconst message = document.createElement('p');\n\t\t\tmessage.innerHTML = 'Time to check if the conditions are met';\n\n\t\t\tconst yesButton = document.createElement('button');\n\t\t\tyesButton.innerHTML = 'Solution finished';\n\t\t\tyesButton.addEventListener('click', e => {\n\t\t\t\tclearMessage(e);\n\t\t\t\tsolutionFinished(e);\n\t\t\t});\n\n\t\t\tconst notButton = document.createElement('button');\n\t\t\tnotButton.innerHTML = 'Need to add a row';\n\t\t\tnotButton.addEventListener('click', e => {\n\t\t\t\tclearMessage(e);\n\t\t\t\tappendNegativeRow(e);\n\t\t\t});\n\n\t\t\tconst messageContainer = document.createElement('div');\n\t\t\tmessageContainer.classList.add('message--container');\n\n\t\t\tmessageContainer.appendChild(message);\n\t\t\tmessageContainer.appendChild(yesButton);\n\t\t\tmessageContainer.appendChild(notButton);\n\n\t\t\toutputContainer.insertBefore( messageContainer, stepButton );\n\n\t\t\tstepButton.hidden = true;\n\t\t} else {\n\t\t\tappendFractionalRow();\n\t\t}\n\t}\n}\n\nstepButton.addEventListener('click', countNextStep);\n\nconst clearMessage = e => {\n\te.target.parentNode.remove();\n}\n\nconst solutionFinished = () => {\n\tconst message = document.createElement('p');\n\tmessage.innerHTML = 'Congratulations!';\n\n\toutputContainer.insertBefore( message, stepButton );\n}\n\nconst appendNegativeRow = () => {\n\tconst lastStep = solveSteps[solveSteps.length - 1];\n\n\tconst nextStep = {\n\t\tsecondary: false,\n\t\tstep: lastStep.step + 1,\n\t\tbasis: {\n\t\t\trow: null,\n\t\t\tcolumn: null\n\t\t},\n\n\t\ttable: lastStep.table.map( arr => arr.slice() ),\n\t}\n\n\tlet maximumIndex = -1;\n\n\tfor (let index = 1; index < nextStep.table[0].length; index++) {\n\t\tconst indexValue = parseIntFromTH(nextStep.table[0][index]);\n\t\tif (indexValue > maximumIndex) {\n\t\t\tmaximumIndex = indexValue;\n\t\t}\n\t}\n\n\tfor (let index = 2; index < nextStep.table.length; index++) {\n\t\tconst indexValue = parseIntFromTH(nextStep.table[index][0]);\n\t\tif (indexValue > maximumIndex) {\n\t\t\tmaximumIndex = indexValue;\n\t\t}\n\t}\n\n\tnextStep.table.push([`x${maximumIndex + 1}`, new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(-1), new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(-1), new _fraction__WEBPACK_IMPORTED_MODULE_0__.Fraction(-1)]);\n\n\tconst stepTable = (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\ttableContent: (0,_fraction__WEBPACK_IMPORTED_MODULE_0__.fractionTableToStrings)(nextStep.table)\n\t});\n\tstepTable.classList.add(`step${nextStep.step}`);\n\tstepTable.classList.add('negative-row');\n\toutputContainer.insertBefore( stepTable, stepButton );\n\n\tsolveSteps.push( nextStep );\n\n\tstepButton.hidden = false;\n}\n\nconst appendFractionalRow = () => {\n\tconst lastStep = solveSteps[solveSteps.length - 1];\n\n\tconst nextStep = {\n\t\tsecondary: false,\n\t\tstep: lastStep.step + 1,\n\t\tbasis: {\n\t\t\trow: null,\n\t\t\tcolumn: null\n\t\t},\n\n\t\ttable: lastStep.table.map( arr => arr.slice() ),\n\t}\n\n\tlet maximumIndex = -1;\n\n\tfor (let index = 1; index < nextStep.table[0].length; index++) {\n\t\tconst indexValue = parseIntFromTH(nextStep.table[0][index]);\n\t\tif (indexValue > maximumIndex) {\n\t\t\tmaximumIndex = indexValue;\n\t\t}\n\t}\n\n\tlet rows = [];\n\n\tfor (let index = 2; index < nextStep.table.length; index++) {\n\t\tconst indexValue = parseIntFromTH(nextStep.table[index][0]);\n\t\t\n\t\trows.push({\n\t\t\tindex: index,\n\t\t\tXindex: indexValue,\n\t\t\tzeros: nextStep.table[index].filter(element => element === 0)\n\t\t});\n\n\t\tif (indexValue > maximumIndex) {\n\t\t\tmaximumIndex = indexValue;\n\t\t}\n\t}\n\n\trows = rows.filter(element => element.zeros.length === 0);\n\trows.sort((element1, element2) => element1.Xindex - element2.Xindex);\n\n\tnextStep.table.push(\n\t\t[`x${maximumIndex + 1}`]\n\t\t\t.concat(\n\t\t\t\tnextStep.table[rows[0].index].slice(1).map( element => element.floor().sub(element) )\n\t\t\t)\n\t);\n\n\tconst stepTable = (0,_table__WEBPACK_IMPORTED_MODULE_1__.generateTable)({\n\t\ttableContent: (0,_fraction__WEBPACK_IMPORTED_MODULE_0__.fractionTableToStrings)(nextStep.table)\n\t});\n\tstepTable.classList.add(`step${nextStep.step}`);\n\tstepTable.classList.add('fractional-row');\n\toutputContainer.insertBefore( stepTable, stepButton );\n\n\tsolveSteps.push( nextStep );\n}\n\n//# sourceURL=webpack://decision_theory_equation_solver/./src/js/equations.js?");

/***/ }),

/***/ "./src/js/table.js":
/*!*************************!*\
  !*** ./src/js/table.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateTable\": () => (/* binding */ generateTable)\n/* harmony export */ });\nconst createInputWithValue = ({\n\tvalue,\n\trow,\n\tcolumn,\n\tupdateCell,\n\ttype = 'text',\n\tplaceholder = 'x'\n}) => {\n\tconst input = document.createElement('input');\n\n\tinput.setAttribute('type', type);\n\tif (type === 'number') {\n\t\tinput.setAttribute('step', '0.0000000000000001');\n\t}\n\tinput.setAttribute('required', 'true');\n\tinput.setAttribute('placeholder', placeholder);\n\tinput.dataset.row = row;\n\tinput.dataset.column = column;\n\n\tinput.addEventListener('input', updateCell);\n\n\tinput.value = value;\n\n\treturn input;\n}\n\nconst generateTable = ({\n\ttableContent,\n\tinitial = false,\n\taddRow = () => {},\n\tdeleteRow = () => {},\n\tupdateCell = () => {},\n}) => {\n\tconst table = document.createElement('div');\n\ttable.classList.add('grid-table');\n\n\tfor (const rowIndex in tableContent) {\n\t\tif (rowIndex == 0) {\n\n\t\t\ttableContent[rowIndex].forEach((data, cellIndex) => {\n\t\t\t\tconst cell = document.createElement('div');\n\t\t\t\tcell.classList.add('headcell');\n\n\t\t\t\tif (initial && cellIndex > 1) {\n\t\t\t\t\tcell.appendChild(createInputWithValue({\n\t\t\t\t\t\tvalue: data,\n\t\t\t\t\t\trow: rowIndex,\n\t\t\t\t\t\tcolumn: cellIndex,\n\t\t\t\t\t\tupdateCell: updateCell,\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tcell.innerHTML = cellIndex > 1 ? `-${data}` : data;\n\t\t\t\t}\n\t\t\t\ttable.appendChild( cell );\n\t\t\t});\n\n\t\t} else {\n\t\t\ttableContent[rowIndex].forEach((data, cellIndex) => {\n\t\t\t\tconst cell = document.createElement('div');\n\t\t\t\tcell.classList.add(cellIndex === 0 ? 'headcell' : 'cell');\n\n\t\t\t\tif (\n\t\t\t\t\tinitial && rowIndex != 1 && cellIndex === 0\n\t\t\t\t) {\n\t\t\t\t\tcell.appendChild(createInputWithValue({\n\t\t\t\t\t\tvalue: data,\n\t\t\t\t\t\trow: rowIndex,\n\t\t\t\t\t\tcolumn: cellIndex,\n\t\t\t\t\t\tupdateCell: updateCell\n\t\t\t\t\t}));\n\n\t\t\t\t} else if (\n\t\t\t\t\tinitial && cellIndex !== 0\n\t\t\t\t) {\n\t\t\t\t\tcell.appendChild(createInputWithValue({\n\t\t\t\t\t\tvalue: data,\n\t\t\t\t\t\trow: rowIndex,\n\t\t\t\t\t\tcolumn: cellIndex,\n\t\t\t\t\t\tupdateCell: updateCell,\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tplaceholder: 0\n\t\t\t\t\t}));\n\n\t\t\t\t} else {\n\t\t\t\t\tcell.innerHTML = String(data).slice(0, 8);\n\t\t\t\t}\n\n\t\t\t\ttable.appendChild( cell );\n\t\t\t});\n\n\t\t\tif (initial && rowIndex > 1) {\n\t\t\t\tconst deleteButton = document.createElement('button');\n\t\t\t\tdeleteButton.classList.add('delete-button');\n\t\t\t\tdeleteButton.innerHTML = 'Delete';\n\n\t\t\t\tdeleteButton.addEventListener('click', e => {\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\tdeleteRow(rowIndex);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttable.children[table.children.length - 1].appendChild(deleteButton);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (initial) {\n\t\tconst createButton = document.createElement('button');\n\t\tcreateButton.classList.add('create-button');\n\t\tcreateButton.innerHTML = 'Add new row';\n\n\t\tcreateButton.addEventListener('click', e => {\n\t\t\te.preventDefault();\n\n\t\t\taddRow();\n\t\t});\n\n\t\tconst createButtonContainer = document.createElement('div');\n\t\tcreateButtonContainer.classList.add('create-button--container');\n\t\tcreateButtonContainer.appendChild( createButton );\n\n\t\ttable.appendChild( createButtonContainer );\n\t}\n\n\treturn table;\n}\n\n\n\n//# sourceURL=webpack://decision_theory_equation_solver/./src/js/table.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/equations.js");
/******/ 	
/******/ })()
;